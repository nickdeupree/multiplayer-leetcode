#!/usr/bin/env python3
"""parse_readmes.py

Scan each folder under lcpy/problems, parse README.md for title, difficulty,
topics, tags, and examples (Input/Output pairs), and write a TypeScript file
that exports a typed array usable by the frontend.

Usage:
  python parse_readmes.py --problems-dir ./problems --out ../frontend/mock_data/problems.ts

"""
import argparse
import json
import os
import re
from typing import List, Dict, Any


def clean_text(s: str) -> str:
    s = s.strip()
    # Remove surrounding code ticks/backticks
    s = s.strip('`')
    return s


def parse_readme(path: str) -> Dict[str, Any]:
    with open(path, 'r', encoding='utf-8') as f:
        text = f.read()
    lines = text.splitlines()

    # Title: first non-empty line that starts with '#'
    title = None
    for ln in lines:
        ln_strip = ln.strip()
        if ln_strip.startswith('#'):
            title = ln_strip.lstrip('#').strip()
            break

    # Difficulty, Topics, Tags via markdown bold lines
    difficulty = None
    topics: List[str] = []
    tags: List[str] = []

    m = re.search(r"^\*\*Difficulty:\*\*\s*(.*)$", text, flags=re.MULTILINE | re.IGNORECASE)
    if m:
        difficulty = clean_text(m.group(1))

    m = re.search(r"^\*\*Topics:\*\*\s*(.*)$", text, flags=re.MULTILINE | re.IGNORECASE)
    if m:
        topics = [t.strip() for t in m.group(1).split(',') if t.strip()]

    m = re.search(r"^\*\*Tags:\*\*\s*(.*)$", text, flags=re.MULTILINE | re.IGNORECASE)
    if m:
        tags = [t.strip() for t in re.split(r",|\s+", m.group(1)) if t.strip() and t.strip() != ',']

    # Examples: collect Input: and Output: lines and pair them (limit to first 2)
    examples: List[Dict[str, str]] = []
    input_pattern = re.compile(r"Input:\s*(.*)", flags=re.IGNORECASE)
    output_pattern = re.compile(r"Output:\s*(.*)", flags=re.IGNORECASE)
    max_examples = 2

    # Walk lines and capture inputs and outputs sequentially
    pending_input = None
    for ln in lines:
        if len(examples) >= max_examples:
            break
        m_in = input_pattern.search(ln)
        if m_in:
            pending_input = clean_text(m_in.group(1))
            continue
        m_out = output_pattern.search(ln)
        if m_out and pending_input is not None:
            output = clean_text(m_out.group(1))
            examples.append({"input": pending_input, "output": output})
            pending_input = None

    # Fallback: if no paired examples found, try scanning code blocks for Input/Output lines (limit to first 2)
    if not examples:
        # find all Input/Output occurrences anywhere
        inputs = input_pattern.findall(text)
        outputs = output_pattern.findall(text)
        for i in range(min(len(inputs), len(outputs), max_examples)):
            examples.append({"input": clean_text(inputs[i]), "output": clean_text(outputs[i])})

    return {
        "title": title or "",
        "difficulty": difficulty,
        "topics": topics,
        "tags": tags,
        "examples": examples,
    }


def generate_typescript(problems: List[Dict[str, Any]]) -> str:
    header = (
        "// THIS FILE IS AUTOGENERATED BY parse_readmes.py - do not edit by hand\n"
        "// Run the script in backend/springboot/lcpy to regenerate.\n\n"
        "export type Example = { input: string; output: string };\n"
        "export type Problem = {\n"
        "  id: string;\n"
        "  title: string;\n"
        "  difficulty: string | null;\n"
        "  topics: string[];\n"
        "  tags: string[];\n"
        "  examples: Example[];\n"
        "};\n\n"
        "export const problems: Problem[] = "
    )

    # Use json.dumps for stable formatting then append TypeScript suffix
    body = json.dumps(problems, indent=2, ensure_ascii=False)
    return header + body + " as Problem[];\n"


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--problems-dir", default="problems", help="Path to lcpy/problems")
    parser.add_argument(
        "--out",
        default="../../frontend/mock_data/problems.ts",
        help="Output TypeScript file path (relative to this script)",
    )
    args = parser.parse_args()

    base = os.path.dirname(os.path.abspath(__file__))
    problems_dir = os.path.join(base, args.problems_dir)
    out_path = os.path.join(base, args.out)

    items: List[Dict[str, Any]] = []

    if not os.path.isdir(problems_dir):
        raise SystemExit(f"Problems directory not found: {problems_dir}")

    for name in sorted(os.listdir(problems_dir)):
        folder = os.path.join(problems_dir, name)
        if not os.path.isdir(folder):
            continue
        readme = os.path.join(folder, "README.md")
        if not os.path.isfile(readme):
            print(f"Skipping {name}: no README.md")
            continue
        data = parse_readme(readme)
        item = {
            "id": name,
            "title": data["title"],
            "difficulty": data["difficulty"],
            "topics": data["topics"],
            "tags": data["tags"],
            "examples": data["examples"],
        }
        items.append(item)

    ts = generate_typescript(items)

    os.makedirs(os.path.dirname(out_path), exist_ok=True)
    with open(out_path, "w", encoding="utf-8") as f:
        f.write(ts)

    print(f"Wrote {len(items)} problems to {out_path}")


if __name__ == "__main__":
    main()
